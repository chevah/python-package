#!/usr/bin/env bash
#
# Chevah Build Script for Python.
#
# build
# test
# publish_production
# publish_staging
#

# Import shared code.
. ./functions.sh

# List of OS packages required for building Python.
UBUNTU_PACKAGES="gcc libssl-dev zlib1g-dev libbz2-dev m4"
RHEL_PACKAGES="gcc openssl-devel zlib-devel bzip2-devel m4"
SLES_PACKAGES="gcc openssl-devel zlib-devel libbz2-devel m4"

LIBFFI_VERSION=3.2.1
GMP_VERSION=6.0.0
PYTHON_BUILD_VERSION=2.7.8
PYSQLITE_VERSION=2.6.3
SQLITE_VERSION=3.8.1

EXTRA_LIBRARIES="\
   python-modules/pyOpenSSL-0.13 \
   python-modules/pycrypto-2.6.1 \
   python-modules/python-setproctitle-1.1.8.dev0 \
   "

PROG=$0
DIST_FOLDER='dist'
BUILD_FOLDER='build'

# Get default values from main paver script.
./paver.sh detect_os
if [ "$?" -ne 0 ]; then
    exit 1
fi
PYTHON_VERSION=`cut -d' ' -f 2 DEFAULT_VALUES`
OS=`cut -d' ' -f 3 DEFAULT_VALUES`
ARCH=`cut -d' ' -f 4 DEFAULT_VALUES`
TIMESTAMP=`date +'%Y%m%d'`
rm DEFAULT_VALUES

# In Solaris and AIX we use $ARCH to choose if we build a 32bit or 64bit
# package. This way we are able to force a 32bit build on a 64bit machine,
# for example by exporting here ARCH as "x86" instead of "x64" or "ppc"
# instead of "ppc64".
# We also use $ARCH when building the external libs in AIX: libffi and GMP.
export ARCH

LOCAL_PYTHON_BINARY_DIST="$PYTHON_VERSION-$OS-$ARCH"
INSTALL_FOLDER=$PWD/${BUILD_FOLDER}/$LOCAL_PYTHON_BINARY_DIST
PYTHON_BIN=$INSTALL_FOLDER/bin/python
PYTHON_BUILD_FOLDER="$PYTHON_VERSION-$OS-$ARCH"

export MAKE=make

case $OS in
    aix*)
        export MAKE=gmake
        export PATH=/usr/vac/bin:$PATH
        export CC=xlc_r
        # CXX is not really needed, we set it to suppress some warnings and
        # to make sure g++ is never used. However, we'll set CPPFLAGS later...
        export CXX=xlC_r
        # IBM's OpenSSL libs are mixed 32/64bit binaries in AIX 7.1, so we need
        # to be specific about what kind of build we want, because GMP by
        # default compiles 64bit libraries.
        if [ "${ARCH%64}" = "$ARCH" ]; then
            export CFLAGS="-O2 -qmaxmem=-1 -q32"
            export OBJECT_MODE="32"
            export ABI="32"
            export AR="ar -X32"
        else
            export CFLAGS="-O2 -qmaxmem=-1 -q64"
            export OBJECT_MODE="64"
            export ABI="mode64"
            export AR="ar -X64"
        fi
        ;;
    solaris*)
        # Solaris 10 has OpenSSL 0.9.7 and Python 2.7 versions starting with
        # 2.7.9 do not support it. More at https://bugs.python.org/issue20981.
        if [ "$OS" = "solaris10" ]; then
            PYTHON_BUILD_VERSION=2.7.8
        fi
        # By default we compile with the Sun Studio compiler. If you want GCC
        # 3.x or 4.x, change this and export the appropriate PATH below.
        export CC=cc
        # CXX is not really needed, we set it to suppress some warnings and
        # to make sure g++ is never used. However, we'll set CPPFLAGS later...
        export CXX=CC
        # This is the default-included GNU make and its counterpart: makeinfo.
        export MAKE=/usr/sfw/bin/gmake
        export MAKEINFO=/usr/sfw/bin/makeinfo
        # We favour the BSD-flavoured "install" over the default one.
        # "ar", "nm" and "ld" are included by default in the same path.
        export PATH=/usr/ccs/bin/:$PATH
        # And this is where the GNU libs are in Solaris 10, including OpenSSL.
        if [ "${ARCH%64}" = "$ARCH" ]; then
            export LDFLAGS="-L/usr/sfw/lib -R/usr/sfw/lib"
        else
            export LDFLAGS="-m64 -L/usr/sfw/lib/64 -R/usr/sfw/lib/64"
            export CFLAGS="-m64"
        fi
        ;;
esac


#
# Install OS package required to build Python.
#
install_dependencies() {

    packages='packages-not-defined'
    install_command='install-command-not-defined'

    case $OS in
        ubuntu*)
            packages=$UBUNTU_PACKAGES
            install_command='sudo apt-get install -y'
        ;;
        rhel*)
            packages=$RHEL_PACKAGES
            install_command='sudo yum install -y'
        ;;
        sles*)
            packages=$SLES_PACKAGES
            install_command='sudo zypper --non-interactive install -l'
        ;;
        aix*)
            # For the moment, we don't install anything on AIX.
            packages=""
            install_command=''
        ;;
        solaris*)
            # For the moment, we don't install anything on Solaris.
            packages=""
            install_command=''
        ;;
        osx*)
            # For the moment, we don't install anything on OSX.
            packages=""
            install_command=''
        ;;
    esac

    # We install one package after another since some package managers
    # (I am looking at you yum) will exit with 0 exit code if at least
    # one package was successfully installed.
    for package in $packages ; do
        execute $install_command $package
    done

}


#
# This function should do the best to remove the packages previously
# installed by `install_dependencies` and leave the system clean.
#
remove_dependencies() {
    case $OS in
        ubuntu*)
            execute sudo apt-get remove -y --purge $UBUNTU_PACKAGES
        ;;
        rhel*)
            execute sudo yum remove -y $RHEL_PACKAGES
        ;;
        sles*)
            execute sudo zypper --non-interactive remove $SLES_PACKAGES
        ;;
    esac
}


help_text_clean="Clean the build."
command_clean() {
    rm -rf ${BUILD_FOLDER}
}

help_text_build="Create the Python binaries for current OS."
command_build() {
    install_dependencies

    case $OS in
        aix*)
            build 'libffi' "libffi-$LIBFFI_VERSION" ${PYTHON_BUILD_FOLDER}
            ;;
        solaris*)
            build 'libffi' "libffi-$LIBFFI_VERSION" ${PYTHON_BUILD_FOLDER}
            ;;
    esac

    # Build GMP on all platforms.
    build 'gmp' "gmp-$GMP_VERSION" ${PYTHON_BUILD_FOLDER}

    build 'python' "Python-$PYTHON_BUILD_VERSION" ${PYTHON_BUILD_FOLDER}

    command_build_sqlite

    command_build_python_extra_libraries

    execute pushd ${BUILD_FOLDER}/${PYTHON_BUILD_FOLDER}
        # Clean the build folder.
        execute rm -rf tmp
        execute mkdir -p lib/config
        safe_move share lib/config
        safe_move pysqlite2-doc lib/config
        # Move all bin to lib/config
        safe_move bin lib/config
        execute mkdir bin
        # Copy back python binary
        execute cp lib/config/bin/$PYTHON_VERSION bin/python
    execute popd

    remove_dependencies

    make_dist 'python' ${PYTHON_BUILD_FOLDER}
}


#
# Build pysqlite with static linked SQLite.
#
command_build_sqlite() {
    target_folder=${BUILD_FOLDER}/pysqlite
    amalgamation_folder=${BUILD_FOLDER}/pysqlite/amalgamation

    initialize_python_module \
        "python-modules/pysqlite-$PYSQLITE_VERSION" $target_folder

    # Prepare SQLite source.
    execute rm -rf $amalgamation_folder
    execute cp -r "src/sqlite/SQLite-$SQLITE_VERSION/" $amalgamation_folder

    # Build and install.
    execute pushd $target_folder
        execute $PYTHON_BIN setup.py build_static
        execute $PYTHON_BIN setup.py install
    execute popd

}

#
# Compile and install all Python extra libraries.
#
command_build_python_extra_libraries() {
    # Update Python config Makefile to use the python that we have just
    # created.
    makefile=$INSTALL_FOLDER/lib/$PYTHON_VERSION/config/Makefile
    makefile_orig=$INSTALL_FOLDER/lib/$PYTHON_VERSION/config/Makefile.orig
    execute cp $makefile $makefile_orig
    sed "s#^prefix=.*#prefix= $INSTALL_FOLDER#" $makefile_orig > $makefile

    # We need GMP or MPIR for fast math in pycrypto. We use GMP because
    # its devs do a better job of supporting exotic platforms such as AIX.
    cp $INSTALL_FOLDER/tmp/gmp/gmp.h $INSTALL_FOLDER/include
    cp $INSTALL_FOLDER/tmp/gmp/libgmp* $INSTALL_FOLDER/lib
    export CPPFLAGS="${CPPFLAGS} -I$INSTALL_FOLDER/include/"
    export LDFLAGS="${LDFLAGS} -L$INSTALL_FOLDER/lib/"

    for library in $EXTRA_LIBRARIES ; do
        # Library is in the form pyopenssl/PyOpenssl-2.4.5
        version_folder=${library#*/}
        target_folder=${BUILD_FOLDER}/$version_folder

        initialize_python_module $library $target_folder

        execute pushd $target_folder
            execute $PYTHON_BIN setup.py install
        execute popd

    done
    execute mv $makefile_orig $makefile
}


#
# Initialize Python module for build.
#
initialize_python_module(){
    source_folder=$1
    larget_folder=$1

    execute rm -rf $target_folder
    execute cp -r $source_folder $target_folder
    execute pushd $target_folder
        if [ -f setup.cfg ] ; then
            echo "include_dirs=$INSTALL_FOLDER/include" >> setup.cfg
            echo "library_dirs=$INSTALL_FOLDER/lib" >> setup.cfg
        fi

        case $OS in
            aix*)
                # Copy special link steps in local folder.
                mkdir -p Modules
                cp $INSTALL_FOLDER/lib/$PYTHON_VERSION/config/* Modules
            ;;
            solaris*)
                # Copy special link steps in local folder.
                mkdir -p Modules
                cp $INSTALL_FOLDER/lib/$PYTHON_VERSION/config/* Modules
                # This is needed for pyOpenSSL.
                if [ "${ARCH%64}" = "$ARCH" ]; then
                    execute $PYTHON_BIN setup.py build_ext -I/usr/sfw/include \
                        -L/usr/sfw/lib
                else
                    execute $PYTHON_BIN setup.py build_ext -I/usr/sfw/include \
                        -L/usr/sfw/lib/64
                fi
            ;;
        esac
    execute popd
}


#
# Test the newly created Python binary dist.
#
help_text_test=\
"Run a quick test for the Python from build."
command_test() {
    test_file='test_python_binary_dist.py'
    execute mkdir -p build/
    execute cp python-modules/chevah-python-test/${test_file} build/
    execute pushd build
    execute ./$LOCAL_PYTHON_BINARY_DIST/bin/python ${test_file}
    execute popd
}


help_text_publish_python=\
"Upload Python binaries for current OS."
command_publish_python() {
    execute rsync -qrlDvcz \
        ${DIST_FOLDER}/$PYTHON_VERSION/ \
        ${BINARY_DIST_PUBLISH_URI}/$PYTHON_VERSION/
}


# Launch the whole thing.
select_command $@
