#!/usr/bin/env bash
#
# Chevah Build Script for Python.
#
# build
# test
# publish_production
# publish_staging
#

# Beware that older versions might be used for selected platforms below.
PYTHON_BUILD_VERSION="2.7.15"
LIBFFI_VERSION="3.2.1"
ZLIB_VERSION="1.2.11"
# We statically build the BSD libedit on selected platforms to get the
# readline module available without linking to the GPL-only readline libs.
LIBEDIT_VERSION="20170329-3.1"
# PyCrypto needs GMP or MPIR for fast math. GMP has support for AIX/HP-UX/etc.
GMP_VERSION="6.1.2"
SQLITE_VERSION="3.23.1"
PYSQLITE_VERSION="2.8.3"
# These are used by get-pip.py.
PIP_VERSION="9.0.3"
SETUPTOOLS_VERSION="39.0.1"

# Python modules versions to be used everywhere possible.
CFFI_VERSION="1.11.5"
PYCRYPTODOME_VERSION="3.6.6"
PYOPENSSL_VERSION="17.5.0"
CRYPTOGRAPHY_VERSION="2.3.1"
SETPROCTITLE_VERSION="1.1.10"
SCANDIR_VERSION="1.9.0"
GMPY2_VERSION="2.0.8"
GMPY_VERSION="1.17"
PYPIWIN32_VERSION="219"

# pycparser needs to be explicitly installed to work around setuptools auto
# dependencies.
PYCPARSER_VERSION="2.14"

# The ID of the redistributable version used on Windows.
REDISTRIBUTABLE_VERSION="9.00.30729.6161"

# Git revision to inject into Python's sys.version string through chevahbs.
PYTHON_PACKAGE_VERSION=$(git rev-parse --short=8 HEAD)

# Export the variables needed by the chevahbs scripts and the test phase.
export PYTHON_BUILD_VERSION PYTHON_PACKAGE_VERSION REDISTRIBUTABLE_VERSION
export BUILD_ZLIB="no"
export BUILD_LIBEDIT="yes"
export BUILD_GMP="yes"
export BUILD_LIBFFI="no"
export BUILD_CFFI="yes"
EXTRA_LIBRARIES="\
    python-modules/cffi-${CFFI_VERSION} \
    "

# Libraries for legacy systems not built around cffi and pip.
# pyOpenSSL 0.13.1 was last upstream version before the port to
# the cffi-based OpenSSL bindings provided by the cryptography module.
# pyOpenSSL 0.13.1, that fixes CVE-2013-4314, requires SSL_set_SSL_CTX.
EXTRA_LIBRARIES_NO_CFFI="\
    python-modules/pyOpenSSL-0.13.1 \
    python-modules/pycryptodome-${PYCRYPTODOME_VERSION} \
    "

# List of python modules installed using pip
PIP_LIBRARIES="\
    setproctitle==${SETPROCTITLE_VERSION} \
    pycryptodome==${PYCRYPTODOME_VERSION} \
    cryptography==${CRYPTOGRAPHY_VERSION} \
    pyOpenSSL==${PYOPENSSL_VERSION} \
    scandir==${SCANDIR_VERSION} \
    "
# Pre-compiled libraries distributed as wheels for Windows.
PIP_LIBRARIES_WIN="$PIP_LIBRARIES \
    pypiwin32==${PYPIWIN32_VERSION} \
    gmpy2==${GMPY2_VERSION} \
    "
# cryptography 1.3.4 was last upstream version to support OpenSSL 0.9.8.
# pyOpenSSL 16.0.0 was last upstream version to support OpenSSL 0.9.8.
PIP_LIBRARIES_OPENSSL_098="\
    setproctitle==${SETPROCTITLE_VERSION} \
    pycryptodome==${PYCRYPTODOME_VERSION} \
    cryptography==1.3.4 \
    pyOpenSSL==16.0.0 \
    scandir==${SCANDIR_VERSION} \
    "
# Python modules installed through pip on systems not build around cffi.
PIP_LIBRARIES_NO_CFFI="\
    setproctitle==${SETPROCTITLE_VERSION} \
    scandir==${SCANDIR_VERSION} \
    "

# Arguments that are sent when using pip.
PIP_ARGS="\
    --index-url http://pypi.chevah.com/simple \
    --trusted-host=pypi.chevah.com \
    "

PROG=$0
DIST_FOLDER='dist'
BUILD_FOLDER='build'

# Import shared code.
. ./functions.sh

# Get default values from main paver script.
./paver.sh detect_os
if [ "$?" -ne 0 ]; then
    exit 1
fi

PYTHON_VERSION=`cut -d' ' -f 2 DEFAULT_VALUES`
OS=`cut -d' ' -f 3 DEFAULT_VALUES`
ARCH=`cut -d' ' -f 4 DEFAULT_VALUES`

# List of OS packages required for building Python/pyOpenSSL/cryptography etc.
COMMON_PKGS="gcc make m4 automake libtool texinfo patch"
COMMON_SLES_PKGS="$COMMON_PKGS git-core zlib-devel libffi-devel ncurses-devel"
DEBIAN_PKGS="$COMMON_PKGS git libssl-dev zlib1g-dev libffi-dev libncurses5-dev"
RHEL_PKGS="$COMMON_PKGS git openssl-devel zlib-devel libffi-devel ncurses-devel"
ALPINE_PKGS=\
    "$COMMON_PKGS git libc-dev libressl-dev zlib-dev libffi-dev ncurses-dev"
ARCH_PKGS="$COMMON_PKGS git libffi ncurses"
case "$OS" in
    rhel5)
        RHEL_PKGS="$RHEL_PKGS automake15"
        ;;
    sles10)
        SLES_PKGS="$COMMON_SLES_PKGS openssl-devel"
        ;;
    sles11sm)
        # SLES 11 with Security Module detected, OpenSSL 1.0.x headers needed.
        SLES_PKGS="$COMMON_SLES_PKGS libopenssl1-devel"
        ;;
    sles11|sles12)
        SLES_PKGS="$COMMON_SLES_PKGS libopenssl-devel"
        ;;
esac

# Lately we don't install anything automatically, we just check for the
# presence of required packages on everything but AIX, HP-UX, macOS, OS X,
# Solaris, Windows and generic Linux builds.
# This build of Python / pyOpenSSL / cryptography / etc.  requires:
# a C compiler, make, m4, libs and headers for OpenSSL / zlib / libffi,
# git (for patching Python's version), patch (for applying our own patches),
# and optionally texinfo (link texinfo to `true` if missing on your platform).
# To build libedit for the readline module, we need the headers of
# a curses library, automake and libtool.
# On platforms with a choice of C compilers, you may choose among the
# available compilers by setting CC and CXX further in this script.

# In Solaris and AIX we use $ARCH to choose if we build a 32bit or 64bit
# package. This way we are able to force a 32bit build on a 64bit machine,
# for example by exporting ARCH in paver.sh as "x86" instead of "x64" or
# "ppc" instead of "ppc64". Except on HP-UX, where we always do 32bit builds.
# We also use $ARCH when building the statically compiled libffi and GMP.
# $OS is used when patching/configuring/building/testing.
export ARCH
export OS
# Explicitly choose the C compiler in order to make it possible to switch
# between native compilers and GCC on platforms such as AIX and Solaris.
export CC='gcc'
# CXX is not really needed, we export it so that g++ won't get picked up when
# not using gcc, and thus silence the associated configure warning on stderr.
export CXX='g++'

LOCAL_PYTHON_BINARY_DIST="$PYTHON_VERSION-$OS-$ARCH"
LOCAL_PYTHON_BINARY=./$LOCAL_PYTHON_BINARY_DIST/bin/python
INSTALL_FOLDER=$PWD/${BUILD_FOLDER}/$LOCAL_PYTHON_BINARY_DIST
PYTHON_BIN=$INSTALL_FOLDER/bin/python
PYTHON_BUILD_FOLDER="$PYTHON_VERSION-$OS-$ARCH"

export MAKE=make

# Used when building cffi.
export CHEVAH_BUILD_PATH=$INSTALL_FOLDER

case $OS in
    aix*)
        # By default, we use IBM's XL C compiler. Remove or comment out the
        # CC and CXX lines to use GCC. However, beware that GCC 4.2 from
        # IBM's RPMs will fail with GMP and Python!
        export CC="xlc_r"
        export CXX="xlC_r"
        export MAKE=gmake
        export PATH=/usr/vac/bin:$PATH
        export CFLAGS="$CFLAGS -O2"
        # IBM's OpenSSL libs are mixed 32/64bit binaries in AIX, so we need to
        # be specific about what kind of build we want, because otherwise we
        # might get 64bit libraries (eg. when building GMP).
        if [ "${ARCH%64}" = "$ARCH" ]; then
            export OBJECT_MODE="32"
            export ABI="32"
            export AR="ar -X32"
            if [ "${CC}" != "gcc" ]; then
                export CFLAGS="$CFLAGS -qmaxmem=-1 -q32"
            fi
        else
            export OBJECT_MODE="64"
            export ABI="mode64"
            export AR="ar -X64"
            if [ "${CC}" != "gcc" ]; then
                export CFLAGS="$CFLAGS -qmaxmem=-1 -q64"
            fi
        fi
        export BUILD_LIBFFI="yes"
        # libedit requires __STDC_ISO_10646__.
        export BUILD_LIBEDIT="no"
        ;;
    solaris*)
        # By default, we use Sun's Studio compiler. Comment these two for GCC.
        export CC="cc"
        export CXX="CC"
        export MAKE="gmake"
        # Here's where the system-included GCC is to be found.
        if [ "${CC}" = "gcc" ]; then
            export PATH="$PATH:/usr/sfw/bin/"
        fi
        # Arch-specific bits and paths.
        if [ "${ARCH%64}" = "$ARCH" ]; then
            # GMP needs to be told that we aim for a 32bit build.
            export ABI="32"
        else
            export CFLAGS="$CFLAGS -m64"
            export LDFLAGS="$LDFLAGS -m64 -L/usr/lib/64 -R/usr/lib/64"
        fi
        if [ "${OS%solaris10*}" = "" ]; then
            # "solaris10" code path requires OpenSSL 1.0.x patches from Oracle.
            # Check "solaris10u3" divergent code path to link to OpenSSL 0.9.7.
            # These are the default-included GNU make and makeinfo.
            export MAKE=/usr/sfw/bin/gmake
            export MAKEINFO=/usr/sfw/bin/makeinfo
            # We favour the BSD-flavoured "install" over the default one.
            # "ar", "nm" and "ld" are included by default in the same path.
            export PATH=/usr/ccs/bin/:$PATH
            # Latest libedit sources do not build on Solaris 10 any more.
            export BUILD_LIBEDIT="no"
            # NPN functions missing from Oracle's OpenSSL patches, as of version
            # 1.0.2n from January 2018 (patches 151912-11/151913-11). Thus, the
            # new _ssl module in 2.7.9 won't build, error being "_ssl.so: symbol
            # SSL_get0_next_proto_negotiated: referenced symbol not found".
            PYTHON_BUILD_VERSION=2.7.8
            # Elliptic-curve crypto missing too, no cryptography 1.9 or newer.
            # NPN functions needed in cryptography 0.4 and newer. 1.8.2 builds,
            # but at runtime: "cryptography/hazmat/bindings/_openssl.so: symbol
            # SSL_CTX_set_next_proto_select_cb: referenced symbol not found".
            # cryptography 0.3 doesn't build on Solaris 10, so we are stuck.
            export BUILD_CFFI="no"
            PIP_LIBRARIES=$PIP_LIBRARIES_NO_CFFI
            EXTRA_LIBRARIES=$EXTRA_LIBRARIES_NO_CFFI
        else
            if [ ${ARCH} = "sparc" ]; then
                # There's a problem with linking readline in 11.2 for SPARC.
                export BUILD_LIBEDIT="no"
            fi
            # Latest cryptography needs EC crypto, enabled in 11.3 SRU19 and
            # newer. Also, latest versions don't build with Studio's CC.
            # https://git.io/fAR2P to be upstreamed after upgrading to 11.3.
            if [ ! -f /usr/include/openssl/ecdh.h ]; then
                # 1.8.2 was last version to build without Elliptic-curve crypto,
                # as this is missing from OpenSSL 1.0.1 libs in Solaris 11.2.
                # pyOpenSSL 17.0.0, last version to support cryptography 1.8.2.
                PIP_LIBRARIES="\
                    setproctitle==${SETPROCTITLE_VERSION} \
                    pycryptodome==${PYCRYPTODOME_VERSION} \
                    cryptography==1.8.2 \
                    pyOpenSSL==17.0.0 \
                    scandir==${SCANDIR_VERSION} \
                    "
            fi
            if [ ! -f /usr/include/openssl/cmac.h ]; then
                # 1.6 still supported OpenSSL 1.0.0, the default in 11.0/11.1.
                # Watch out for errors related to "-Wconversion".
                PIP_LIBRARIES="\
                    setproctitle==${SETPROCTITLE_VERSION} \
                    pycryptodome==${PYCRYPTODOME_VERSION} \
                    cryptography==1.6 \
                    pyOpenSSL==${PYOPENSSL_VERSION} \
                    scandir==${SCANDIR_VERSION} \
                    "
            fi
        fi
        if [ "$OS" = "solaris10u3" ]; then
            # This code path also covers linking to OpenSSL 0.9.7 on all Solaris
            # 10 versions, including releases u7 and newer, with updated libc.
            # Paths for OpenSSL 0.9.7 and SQLite libs on Solaris 10.
            # The latter were moved and are found easily on newer releases.
            if [ "${ARCH%64}" = "$ARCH" ]; then
                export LDFLAGS="$LDFLAGS -L/usr/sfw/lib -R/usr/sfw/lib"
                export LDFLAGS="$LDFLAGS -L/usr/lib/mps -R/usr/lib/mps"
            else
                export LDFLAGS="$LDFLAGS -L/usr/sfw/lib/64 -R/usr/sfw/lib/64"
                export LDFLAGS="$LDFLAGS -L/usr/lib/mps/64 -R/usr/lib/mps/64"
            fi
            # pip doesn't like the included zlib on ancient Solaris 10
            # releases, such as Solaris 10u3.
            export BUILD_ZLIB="yes"
            # Solaris 10 has OpenSSL 0.9.7, but Python 2 versions starting with
            # 2.7.9 do not support it, see https://bugs.python.org/issue20981.
            PYTHON_BUILD_VERSION=2.7.8
            # OpenSSL 0.9.7 is unusable with cryptography & current pyOpenSSL.
            # Beware that OpenSSL 0.9.7 libs, as bundled in Solaris 10, lack
            # the SSL_set_SSL_CTX symbol.
            # pyOpenSSL 0.13 was last version to build without SSL_set_SSL_CTX.
            export BUILD_CFFI="no"
            # If latest setproctitle fails, look in the history of this repo
            # for python-modules/python-setproctitle-1.1.8.dev0 for extra libs.
            PIP_LIBRARIES=$PIP_LIBRARIES_NO_CFFI
            EXTRA_LIBRARIES=$EXTRA_LIBRARIES_NO_CFFI
        fi
        ;;
    hpux*)
        # GCC and the bundled /usr/ccs/bin/cc will fail with pycrypto.
        # "aCC -Ae" does parallel builds better, but beware of race conditions.
        # Don't use CFLAGS with native ld, it chokes on some parameters.
        # An alternative is LDSHARED="/opt/aCC/bin/aCC -b" with CC="aCC -Ae".
        # As little warnings as possible, HP's compilers generate lots.
        # Force 32bit binaries (the OS default) and Position-Independent Code.
        export CC="/opt/aCC/bin/cc -w +DD32 +z"
        export CXX="/opt/aCC/bin/aCC"
        # Native make needed for parallel builds, use gmake where this breaks.
        export MAKE="make -P"
        # Even though we don't use CFFI, libffi is needed to build _ctypes,
        # which is then needed by gmpy 1.x
        export BUILD_LIBFFI="yes"
        export BUILD_ZLIB="yes"
        # CFFI/cryptography build on HP-UX, but libffi breaks for CFFI. More at
        # https://bitbucket.org/cffi/cffi/issues/368/segmentation-fault-in-hp-ux
        export BUILD_CFFI="no"
        PIP_LIBRARIES=$PIP_LIBRARIES_NO_CFFI
        EXTRA_LIBRARIES=$EXTRA_LIBRARIES_NO_CFFI
        # libedit requires __STDC_ISO_10646__.
        export BUILD_LIBEDIT="no"
        ;;
    osx*)
        # The extra params needed to set the minimum target version to 10.8
        # have the important benefit of getting rid of the libgcc dependency.
        export CC="clang"
        export CXX="clang++"
        export CFLAGS="$CFLAGS -mmacosx-version-min=10.8"
        export MACOSX_DEPLOYMENT_TARGET=10.8
        # OS X 10.8 not supported by cryptography 1.9, so you'll normally use
        # 1.8.2, but cryptography 2.2.2 has a working wheel for MacOS 10.6+.
        # It currently bundles OpenSSL 1.1.0h with cryptography 2.2.2.
        PIP_LIBRARIES="\
            setproctitle==${SETPROCTITLE_VERSION} \
            pycryptodome==${PYCRYPTODOME_VERSION} \
            cryptography==${CRYPTOGRAPHY_VERSION}upstream \
            pyOpenSSL==${PYOPENSSL_VERSION} \
            scandir==${SCANDIR_VERSION} \
            "
        ;;
    macos*)
        # On macOS 10.12 or newer we need the Homebrew version of OpenSSL,
        # as Apple only provides an old OpenSSL version: 0.9.8.
        export CC="clang"
        export CXX="clang++"
        # The location of the Homebrew OpenSSL libs and include directories.
        export LDFLAGS="-L/usr/local/opt/openssl/lib $LDFLAGS"
        export CPPFLAGS="$CPPFLAGS -I/usr/local/opt/openssl/include"
        # setup.py skips building readline by default, as it sets this to
        # "10.4", and then tries to avoid the broken readline in OS X 10.4.
        export MACOSX_DEPLOYMENT_TARGET=10.11
        ;;
    freebsd*|openbsd*)
        export CC="clang"
        export CXX="clang++"
        export BUILD_LIBFFI="yes"
        ;;
    linux*)
        # We don't compile libedit for generic Linux builds because it links
        # to local ncurses libs and the result is not very portable.
        export BUILD_LIBEDIT="no"
        ;;
    sles11sm)
        # Use PyCryptodome's wheel, as there are issues not solved upstream yet.
        PIP_LIBRARIES="\
            setproctitle==${SETPROCTITLE_VERSION} \
            pycryptodome==${PYCRYPTODOME_VERSION}upstream \
            cryptography==${CRYPTOGRAPHY_VERSION} \
            pyOpenSSL==${PYOPENSSL_VERSION} \
            scandir==${SCANDIR_VERSION} \
            "
        ;;
    rhel5|sles11)
        # OS'es with OpenSSL 0.9.8 libs, older cryptography would be needed,
        # but upstream provides a Linux wheel that works, at least on SLES 11.
        # It currently bundles OpenSSL 1.1.0h with cryptography 2.2.2.
        # Otherwise, just set PIP_LIBRARIES to PIP_LIBRARIES_OPENSSL_098.
        # Use PyCryptodome's wheel, as there are issues not solved upstream yet.
        PIP_LIBRARIES="\
            setproctitle==${SETPROCTITLE_VERSION} \
            pycryptodome==${PYCRYPTODOME_VERSION}upstream \
            cryptography==${CRYPTOGRAPHY_VERSION}upstream \
            pyOpenSSL==${PYOPENSSL_VERSION} \
            scandir==${SCANDIR_VERSION} \
            "
        ;;
    sles10)
        export BUILD_CFFI="no"
        PIP_LIBRARIES=$PIP_LIBRARIES_NO_CFFI
        EXTRA_LIBRARIES=$EXTRA_LIBRARIES_NO_CFFI
        ;;
    windows*)
        # On Windows, python executable is installed at a different path.
        LOCAL_PYTHON_BINARY=./$LOCAL_PYTHON_BINARY_DIST/lib/python
        PYTHON_BIN=$INSTALL_FOLDER/lib/python
        # On windows extra libraries are installed only using PIP.
        EXTRA_LIBRARIES=""
        PIP_LIBRARIES=$PIP_LIBRARIES_WIN
        # For Windows we don't build everything from source yet.
        export BUILD_LIBEDIT="no"
        export BUILD_GMP="no"
        ;;
esac

# Compiler-dependent flags. At this moment we should know what compiler is used.
if [ "${OS%solaris*}" = "" ]; then
    if [ ${ARCH} = "sparc64" ]; then
        # Required for compiling GMP on Solaris for SPARC with Sun Studio.
        export CFLAGS="$CFLAGS -xcode=abs64"
    fi
elif [ "${OS%freebsd*}" = "" -o "${OS%openbsd*}" = "" ]; then
    # Use PIC (Position Independent Code) on FreeBSD and OpenBSD with Clang.
    export CFLAGS="${CFLAGS} -fPIC"
elif [ "$CC" = "gcc" -a ${ARCH%%64} != "$ARCH" ]; then
    # Use PIC (Position Independent Code) with GCC on 64-bit arches.
    export CFLAGS="${CFLAGS} -fPIC"
fi

# Parallel builds where applicable.
get_number_of_cpus
JOBS=1
case "$ARCH" in
    sparc*)
        # Twice the number of physical CPUs is optimal on SPARC machines.
        let JOBS=2*CPUS
        ;;
    *)
        # On other virtual and physical machines this is close to optimum.
        let JOBS=CPUS
        ;;
esac
if [ "${OS%hpux*}" = "" ]; then
    export PARALLEL="$JOBS"
else
    export MAKE="$MAKE -j${JOBS}"
fi


#
# Check for OS packages required to build Python.
#
check_dependencies() {

    packages=''
    missing_packages=''

    case $OS in
        # Debian-derived distros are similar in this regard.
        ubuntu*|raspbian*)
            packages=$DEBIAN_PKGS
            check_command='dpkg --status'
            ;;
        rhel*)
            packages=$RHEL_PKGS
            check_command='rpm --query'
            ;;
        sles*)
            packages=$SLES_PKGS
            check_command='rpm --query'
            ;;
        alpine*)
            packages=$ALPINE_PKGS
            check_command='apk info'
            ;;
        archlinux)
            packages=$ARCH_PKGS
            check_command='pacman -Qi'
            ;;
        macos*)
            # On macOS we need OpenSSL installed via Homebrew, and here we
            # check that the expected version is installed, as hardcoded below.
            homebrew_openssl_version=`brew list --versions openssl`
            if [[ $homebrew_openssl_version != "openssl 1.0.2"* ]]; then
                echo "Unsupported OpenSSL version: $homebrew_openssl_version"
                exit 102
            fi
            # But we also check for the required commands, as for below OS'es.
            packages="$CC make m4 libtool git patch"
            check_command="command -v"
            ;;
        # On remaining OS'es we just check for some of the needed commands.
        windows)
            # The windows build is special.
            packages="make git patch"
            check_command="command -v"
            ;;
        hpux*)
            # Included CFLAGS get in the way on HP-UX.
            packages="/opt/aCC/bin/cc make m4 git patch"
            check_command="command -v"
            ;;
        *)
            packages="$CC make m4 git patch"
            check_command="command -v"
            ;;
    esac

    if [ -n "$packages" ]; then
        echo "Checking for required packages or commands..."
        for package in $packages ; do
            echo "Checking if $package is available..."
            $check_command $package
            if [ $? -ne 0 ]; then
                echo "Missing required dependency: $package"
                missing_packages="$missing_packages $package"
            fi
        done
    fi

    if [ -n "$missing_packages" ]; then
        echo "Sorry, following dependencies were not found: $missing_packages."
        exit 101
    fi
    if [ -n "$packages" ]; then
        echo "All required dependencies are present: $packages"
    fi

}


help_text_clean="Clean the build."
command_clean() {
    if [ -e ${BUILD_FOLDER} ]; then
        echo 'Previous build sub-directory found. Removing...'
        rm -rf ${BUILD_FOLDER}
    fi
}

help_text_build="Create the Python binaries for current OS."
command_build() {
    check_dependencies

    # Clean the build dir to avoid contamination from previous builds.
    command_clean

    # Build stuff statically on most platforms, install headers and libs in the
    # following locations and make sure they are picked up when building Python.
    # We used to add the new include path to $CPPFLAGS, but it's not as portable
    # as copying the includes (HP-UX's linker fails with -I when not using GCC).
    mkdir -p $INSTALL_FOLDER/{include,lib}
    export LDFLAGS="-L${INSTALL_FOLDER}/lib/ ${LDFLAGS}"
    export PKG_CONFIG_PATH="${INSTALL_FOLDER}/lib/pkgconfig/:${PKG_CONFIG_PATH}"

    if [ "$BUILD_LIBFFI" = "yes" ]; then
        build 'libffi' "libffi-$LIBFFI_VERSION" ${PYTHON_BUILD_FOLDER}
    else
        (>&2 echo "Skipping building LIBFFI!")
    fi

    if [ "$BUILD_ZLIB" = "yes" ]; then
        build 'zlib' "zlib-$ZLIB_VERSION" ${PYTHON_BUILD_FOLDER}
    else
        (>&2 echo "Skipping building ZLIB!")
    fi

    if [ "$BUILD_LIBEDIT" = "yes" ]; then
        build 'libedit' "libedit-$LIBEDIT_VERSION" ${PYTHON_BUILD_FOLDER}
    else
        (>&2 echo "Skipping building LIBEDIT!")
    fi

    if [ "$BUILD_GMP" = "yes" ]; then
        build 'gmp' "gmp-$GMP_VERSION" ${PYTHON_BUILD_FOLDER}
    else
        (>&2 echo "Skipping building GMP!")
    fi

    case $OS in
        windows*)
            build 'python' "Python-$PYTHON_BUILD_VERSION-windows" ${PYTHON_BUILD_FOLDER}
            ;;
        *)
            build 'python' "Python-$PYTHON_BUILD_VERSION" ${PYTHON_BUILD_FOLDER}
            ;;
    esac

    aix_ld_hack init
    command_build_sqlite
    command_build_gmpy
    command_build_python_extra_libraries
    aix_ld_hack cleanup

    case $OS in
        windows*)
            echo "Skipping cleaning install folder"
            ;;
        *)
            execute pushd ${BUILD_FOLDER}/${PYTHON_BUILD_FOLDER}
                # Clean the build folder.
                execute rm -rf tmp
                execute mkdir -p lib/config
                safe_move share lib/config
                safe_move pysqlite2-doc lib/config
                # Move all bin to lib/config
                safe_move bin lib/config
                execute mkdir bin
                # Copy back python binary
                execute cp lib/config/bin/$PYTHON_VERSION bin/python
            execute popd
            ;;
    esac

    # Output the python-package version to a dedicated file in the archive.
    echo "${PYTHON_BUILD_VERSION}.${PYTHON_PACKAGE_VERSION}" \
        > ${BUILD_FOLDER}/${PYTHON_BUILD_FOLDER}/lib/PYTHON_PACKAGE_VERSION

    make_dist 'python' ${PYTHON_BUILD_FOLDER}
}


#
# Build pysqlite with static linked SQLite.
#
command_build_sqlite() {

    if [ $OS = 'windows' ]; then
        echo "Updating SQLite DLL on Windows..."
        execute cp src/sqlite/sqlite3-${SQLITE_VERSION}.dll \
            ${INSTALL_FOLDER}/lib/DLLs/sqlite3.dll
        return
    fi

    target_folder=${BUILD_FOLDER}/pysqlite

    initialize_python_module \
        "python-modules/pysqlite-$PYSQLITE_VERSION" $target_folder

    # Bring SQLite headers and source handy.
    execute cp src/sqlite/SQLite-${SQLITE_VERSION}/*.h \
        ${INSTALL_FOLDER}/include/
    execute cp src/sqlite/SQLite-${SQLITE_VERSION}/sqlite3.c ${target_folder}/

    # Build and install.
    execute pushd $target_folder
        execute $PYTHON_BIN setup.py build_static
        execute $PYTHON_BIN setup.py install
    execute popd

}

#
# Build gmpy2 without MPFR and MPC library support.
# Beware that beginning with v2.1.0, MPFR and MPC will be required.
# On Windows we use the upstream wheel.
# On HP-UX gmpy2 is problematic, so we build gmpy.
#
command_build_gmpy() {

    if [ $OS = 'windows' ]; then
        return
    fi

    if [ $OS = 'hpux1131' ]; then
        target_folder=${BUILD_FOLDER}/gmpy

        initialize_python_module \
            "python-modules/gmpy-$GMPY_VERSION" $target_folder

        # Build and install.
        execute pushd $target_folder
            execute $PYTHON_BIN setup.py install
        execute popd
        return
    fi

    target_folder=${BUILD_FOLDER}/gmpy2

    initialize_python_module \
        "python-modules/gmpy2-$GMPY2_VERSION" $target_folder

    # Build and install.
    execute pushd $target_folder
        execute $PYTHON_BIN setup.py install --nompfr
    execute popd
}

#
# Compile and install all Python extra libraries.
#
command_build_python_extra_libraries() {

    # Install the latest PIP and setuptools.
    # But first patch it to get the exact version.
    # get-pip will always try to get the latest version, so we ask it to not
    # install things and then we manually pass what we want to install.
    execute $PYTHON_BIN python-modules/get-pip.py $PIP_ARGS \
        pip==$PIP_VERSION --no-setuptools setuptools==$SETUPTOOLS_VERSION

    # pycparser is installed first as setup_requires is ugly.
    # https://pip.pypa.io/en/stable/reference/pip_install/#controlling-setup-requires
    execute $PYTHON_BIN -m pip \
        install $PIP_ARGS -U pycparser==$PYCPARSER_VERSION

    if [ $OS = 'windows' ]; then
        echo "Skipping makefile updating on Windows"
    else
        # Update Python config Makefile to use the python that we have just
        # created.
        makefile=$INSTALL_FOLDER/lib/$PYTHON_VERSION/config/Makefile
        makefile_orig=$INSTALL_FOLDER/lib/$PYTHON_VERSION/config/Makefile.orig

        execute cp $makefile $makefile_orig
        execute sed "s#^prefix=.*#prefix= $INSTALL_FOLDER#" $makefile_orig \
            > $makefile
    fi

    for library in $EXTRA_LIBRARIES ; do
        # Library is in the form pyopenssl/PyOpenssl-2.4.5
        version_folder=${library#*/}
        target_folder=${BUILD_FOLDER}/$version_folder

        initialize_python_module $library $target_folder

        execute pushd $target_folder
            execute $PYTHON_BIN setup.py install
        execute popd

    done

    for library in $PIP_LIBRARIES ; do
        execute $PYTHON_BIN -m pip install $PIP_ARGS $library
    done

    if [ $OS == "windows" ]; then
        echo "Patching pyWin32 manifests to use our redistributable version"
        wipe_manifest $INSTALL_FOLDER/lib/Lib/site-packages/win32/pythonservice.exe
        wipe_manifest $INSTALL_FOLDER/lib/Lib/site-packages/win32/perfmondata.dll
        wipe_manifest $INSTALL_FOLDER/lib/Lib/site-packages/pywin32_system32/pythoncomloader27.dll

        echo "Copy Python runtime to pyWin32 package"
        execute cp $INSTALL_FOLDER/lib/*CRT.manifest \
            $INSTALL_FOLDER/lib/Lib/site-packages/win32/
        execute cp $INSTALL_FOLDER/lib/python27.dll.manifest \
            $INSTALL_FOLDER/lib/Lib/site-packages/win32/
        execute cp $INSTALL_FOLDER/lib/python27.dll \
            $INSTALL_FOLDER/lib/Lib/site-packages/win32/
        execute cp $INSTALL_FOLDER/lib/msvc?90.dll \
            $INSTALL_FOLDER/lib/Lib/site-packages/win32/
        execute cp $INSTALL_FOLDER/lib/Lib/site-packages/pywin32_system32/*.dll \
            $INSTALL_FOLDER/lib/Lib/site-packages/win32/
    fi

}


#
# Initialize Python module for build.
#
initialize_python_module(){
    source_folder=$1
    target_folder=$2

    execute rm -rf $target_folder
    execute cp -r $source_folder $target_folder
    execute pushd $target_folder
        if [ -f setup.cfg ] ; then
            echo "[build_ext]" >> setup.cfg
            echo "include_dirs=$INSTALL_FOLDER/include" >> setup.cfg
            echo "library_dirs=$INSTALL_FOLDER/lib" >> setup.cfg

            # We want to download dependencies from our PyPI and block
            # the official.
            echo "[easy_install]" >> setup.cfg
            echo "find_links=http://pypi.chevah.com/" >> setup.cfg
            echo "allow_hosts=*pypi.chevah.com*" >> setup.cfg
        fi

        case $OS in
            solaris10u3*)
                # Copy special link steps in local folder.
                mkdir -p Modules
                cp $INSTALL_FOLDER/lib/$PYTHON_VERSION/config/* Modules
                extra_args=""
                 # To link pyOpenSSL to included OpenSSL 0.9.7 libs.
                extra_args="$extra_args -I/usr/sfw/include"
                if [ "${ARCH%64}" = "$ARCH" ]; then
                    extra_args="$extra_args -L/usr/sfw/lib"
                else
                    extra_args="$extra_args -L/usr/sfw/lib/64"
                fi
                execute $PYTHON_BIN setup.py build_ext $extra_args
                ;;
        esac
    execute popd
}


#
# Test the newly created Python binary dist.
#
help_text_test=\
"Run a quick test for the Python from build."
command_test() {
    test_file='test_python_binary_dist.py'
    execute mkdir -p build/
    execute cp python-modules/chevah-python-test/${test_file} build/
    execute cp python-modules/chevah-python-test/get_binaries_deps.sh build/
    execute pushd build

    echo '##### Executing Chevah tests... #####'
    execute $LOCAL_PYTHON_BINARY ${test_file}

    echo '##### Testing for outdated packages and security issues... #####'
    execute $PYTHON_BIN -m pip list $PIP_ARGS --outdated --format=columns
    execute $PYTHON_BIN -m pip install $PIP_ARGS safety
    execute $PYTHON_BIN -m safety check --full-report

    echo '##### Executing tests for included Python modules... #####'

    # This test requires quite some RAM, so beware of heavy swapping.
    echo 'Testing PyCryptodome...'
    case "$OS-$ARCH" in
        hpux*)
            # FIXME:5017:
            # CFFI crashes on HP-UX.
            (>&2 echo -e "\tSkipping because of cffi-related crash.")
            ;;

        *)
            execute $LOCAL_PYTHON_BINARY -m Crypto.SelfTest
            ;;
    esac

    echo 'Testing scandir...'
    # There are a series of issues with the scandir tests in Linux/Unix.
    # Reported upstream at https://github.com/benhoyt/scandir/issues/78.
    SCANDIR_FOLDER="../python-modules/scandir-${SCANDIR_VERSION}"
    case "$OS-$ARCH" in
        osx*|macos*|windows*)
            execute $LOCAL_PYTHON_BINARY ${SCANDIR_FOLDER}/test/run_tests.py
            ;;
        aix*|hpux*|solaris10-sparc)
            (>&2 echo -e "\tSkipping because of upstream issues.")
            ;;
        *)
            # Remaining build slaves have the required UTF-8 locale settings
            # available, but they need to be requested for the tests to pass.
            export LC_ALL=en_US.UTF-8
            execute $LOCAL_PYTHON_BINARY ${SCANDIR_FOLDER}/test/run_tests.py
            export LC_ALL=C
            ;;
    esac

    execute popd
}


#
# Test the newly created Python binary dist.
#
help_text_test_compat=\
"Run a full test for the chevah/compat master."
command_test_compat() {

    # compat is not suported on these platforms, so no need to test.
    case "$OS-$ARCH" in
        freebsd11*|solaris11-sparc)
            (>&2 echo -e "\tCompat tests not supported on this platform.")
            return
            ;;
    esac

    execute pushd build

    # To have a better test coverage, we run the tests on compat.
    # Some parts of this is a big hack as we have to force compat to use
    # the local version.
    echo '##### Running chevah.compat tests... #####'
    execute rm -rf compat
    execute git clone https://github.com/chevah/compat.git --depth=1 -b master
    execute pushd compat
    # We patch the Python version to match the one that we have just built
    # and copy it in cache so that it will be picked up by the new build.
    execute echo -e "\nPYTHON_CONFIGURATION=default@${PYTHON_BUILD_VERSION}.${PYTHON_PACKAGE_VERSION}" >> paver.conf
    # Also copy latest paver.sh, as some changes might require it.
    execute cp ../../paver.sh ./
    # Populate the cache with the latest version so that we don't have to
    # download it.
    execute mkdir cache
    execute cp -r ../$LOCAL_PYTHON_BINARY_DIST cache/
    # Some tests might fail due to causes which are not related to python.
    execute ./paver.sh test_ci
    execute popd

    execute popd
}


help_text_publish_python=\
"Upload Python binaries for current OS."
command_publish_python() {
    execute rsync -qrlDvcz \
        ${DIST_FOLDER}/$PYTHON_VERSION/ \
        ${BINARY_DIST_PUBLISH_URI}/$PYTHON_VERSION/
}


# Launch the whole thing.
select_command $@
